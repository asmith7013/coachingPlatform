/**
 * Question Variant Mapping Utility
 *
 * COMMENTED OUT: This file relied on docs/question-variant-mapping.json which was
 * deleted due to memory issues. The complex variant analysis is no longer used.
 * We now use a simpler approach in section-configs where we just save the first N
 * questions as root questions.
 *
 * Loads and provides access to the question variant mapping generated by
 * scripts/analyze-question-variants.py
 *
 * This mapping identifies which questions are "root" questions vs "variants"
 * based on code similarity analysis.
 */

// COMMENTED OUT: JSON file deleted to reduce memory usage
// import rawMapping from '@/../docs/question-variant-mapping.json';

// COMMENTED OUT: Type definitions no longer needed
// type RawMappingEntry = {
//   type: 'root' | 'variant';
//   groupId: number;
//   rootQuestionId?: number;
// };

// type RawMapping = Record<string, RawMappingEntry>;

// const questionVariantMapping = rawMapping as RawMapping;

// COMMENTED OUT: Interface and functions no longer functional without JSON data
// export interface QuestionVariantInfo {
//   type: 'root' | 'variant';
//   groupId: number;
//   rootQuestionId?: number;
// }

// /**
//  * Get variant information for a specific question ID
//  *
//  * @param questionId - The Podsie question ID (as number or string)
//  * @returns Variant info object, or null if question not in mapping
//  */
// export function getQuestionVariantInfo(questionId: number | string): QuestionVariantInfo | null {
//   const id = String(questionId);
//   const info = questionVariantMapping[id];

//   if (!info) {
//     return null;
//   }

//   return {
//     type: info.type,
//     groupId: info.groupId,
//     rootQuestionId: info.rootQuestionId
//   };
// }

// COMMENTED OUT: All functions below are non-functional without the JSON mapping data
// /**
//  * Check if a question is a root question
//  */
// export function isRootQuestion(questionId: number | string): boolean {
//   const info = getQuestionVariantInfo(questionId);
//   return info?.type === 'root' || info === null; // Default to root if not in mapping
// }

// /**
//  * Check if a question is a variant
//  */
// export function isVariantQuestion(questionId: number | string): boolean {
//   const info = getQuestionVariantInfo(questionId);
//   return info?.type === 'variant';
// }

// /**
//  * Get the root question ID for a variant
//  */
// export function getRootQuestionId(questionId: number | string): number | null {
//   const info = getQuestionVariantInfo(questionId);
//   if (info?.type === 'variant' && info.rootQuestionId) {
//     return info.rootQuestionId;
//   }
//   return null;
// }

// /**
//  * Get all questions in the same variant group
//  */
// export function getVariantGroup(questionId: number | string): number[] {
//   const info = getQuestionVariantInfo(questionId);
//   if (!info) return [];

//   const groupId = info.groupId;

//   // Find all questions with the same groupId
//   return Object.entries(questionVariantMapping)
//     .filter(([_, data]) => data.groupId === groupId)
//     .map(([id]) => parseInt(id, 10));
// }

// /**
//  * Get variant number for a question within its group
//  * Root question returns 0, first variant returns 1, etc.
//  */
// export function getVariantNumber(questionId: number | string, questionIds: number[]): number {
//   const info = getQuestionVariantInfo(questionId);
//   if (!info) return 0;

//   if (info.type === 'root') return 0;

//   // Find all variants with the same root in the provided question list
//   const rootId = info.rootQuestionId;
//   const variants = questionIds.filter(id => {
//     const variantInfo = getQuestionVariantInfo(id);
//     return variantInfo?.type === 'variant' && variantInfo.rootQuestionId === rootId;
//   });

//   // Sort variants by their question ID to ensure consistent numbering
//   variants.sort((a, b) => a - b);

//   // Find the index of this question in the sorted variants
//   const index = variants.indexOf(Number(questionId));
//   return index >= 0 ? index + 1 : 0;
// }

// /**
//  * Map an array of question IDs to their variant info
//  * Useful for creating podsieQuestionMap in section configs
//  *
//  * @param questionIds - Array of question IDs to map
//  * @param rootsOnly - If true, only include root questions (default: false for full mapping)
//  */
// export function mapQuestionsToVariantInfo(
//   questionIds: (number | string)[],
//   rootsOnly: boolean = false
// ) {
//   const allMapped = questionIds.map((questionId, index) => {
//     const info = getQuestionVariantInfo(questionId);
//     const isRoot = !info || info.type === 'root';

//     const result: {
//       questionNumber: number;
//       questionId: string;
//       isRoot: boolean;
//       rootQuestionId?: string;
//       variantNumber?: number;
//     } = {
//       questionNumber: index + 1,
//       questionId: String(questionId),
//       isRoot
//     };

//     if (info?.type === 'variant' && info.rootQuestionId) {
//       result.rootQuestionId = String(info.rootQuestionId);
//       result.variantNumber = getVariantNumber(questionId, questionIds.map(id => Number(id)));
//     }

//     return result;
//   });

//   // If rootsOnly, filter and renumber
//   if (rootsOnly) {
//     const rootsFiltered = allMapped.filter(q => q.isRoot);
//     // Renumber questions sequentially
//     return rootsFiltered.map((q, index) => ({
//       ...q,
//       questionNumber: index + 1
//     }));
//   }

//   return allMapped;
// }

// /**
//  * Get statistics about root vs variant questions in an array
//  */
// export function getQuestionStats(questionIds: (number | string)[]) {
//   const stats = {
//     total: questionIds.length,
//     roots: 0,
//     variants: 0,
//     unmapped: 0
//   };

//   for (const id of questionIds) {
//     const info = getQuestionVariantInfo(id);
//     if (!info) {
//       stats.unmapped++;
//     } else if (info.type === 'root') {
//       stats.roots++;
//     } else {
//       stats.variants++;
//     }
//   }

//   return stats;
// }
