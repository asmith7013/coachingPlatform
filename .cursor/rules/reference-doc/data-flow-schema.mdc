---
description: This document defines the data flow architecture of the platform, where Zod schemas are the single source of truth across frontend, backend, and database layers. It should be referenced by the agent when generating anything involving schema definitions, form field configurations, data fetching hooks, or server actions.
globs: 
alwaysApply: false
---
<doc id="data-flow">

# Data Flow & Schema System

<section id="data-overview">

## Overview

Our platform uses a schema-driven architecture where Zod schemas serve as the definitive source of truth for all data structures. This approach ensures consistency across the frontend, backend, and database layers.

[RULE] Always use Zod schemas as the canonical source of truth for data structures.

</section>

<section id="data-schemas">

## Zod Schema Architecture

Schemas are organized in `src/lib/zod-schema/` by domain:

- `core/`: Base schemas for common entities (School, Staff, Cycle)
- `shared/`: Reusable schema parts (notes, enums, date helpers)
- Domain-specific directories: `visits/`, `look-fors/`, etc.

```typescript
// Example: School schema
export const SchoolZodSchema = z.object({
  _id: z.string(),
  schoolNumber: z.string(),
  district: z.string(),
  schoolName: z.string(),
  address: z.string().optional(),
  gradeLevelsSupported: z.array(GradeLevelsSupportedZod),
  staffList: z.array(z.string()),
  owners: z.array(z.string()),
  createdAt: zDateField.optional(),
  updatedAt: zDateField.optional(),
});
```

[RULE] When adding new fields, always start by updating the Zod schema first.

</section>

<section id="data-form-config">

## Field Configuration System

Field configurations in `src/lib/ui-schema/fieldConfig/` define how form fields should be rendered and validated:

```typescript
export const SchoolFieldConfig: Field<SchoolInput>[] = [
  {
    name: 'schoolNumber',
    label: 'School Number',
    type: 'text',
    required: true,
  },
  {
    name: 'district',
    label: 'District',
    type: 'text',
    required: true,
  },
  // Additional fields...
];
```

[RULE] Field configs should reference schema properties rather than redefining them.

</section>

<section id="data-form-overrides">

## Form Overrides

Form overrides (`src/lib/ui-schema/formOverrides/`) allow customization of form behavior for specific contexts:

```typescript
export const SchoolOverrides: FieldOverrideMap<SchoolInput> = {
  district: {
    type: 'reference',
    label: 'District',
    url: '/api/districts',
    multiple: false,
  },
  // Additional overrides...
};
```

[RULE] Use form overrides to customize field behavior without modifying the base schema.

</section>

<section id="data-hooks">

## Data Fetching Hooks

Custom hooks for data fetching provide a consistent interface across the application:

```typescript
function useSchools() {
  const [schools, setSchools] = useState<School[]>([]);
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  // Implementation...
  
  return {
    schools,
    error,
    isLoading,
    createSchool,
    updateSchool,
    deleteSchool,
  };
}
```

[RULE] Always return error and loading states from data hooks.

</section>

<section id="data-reference-hook">

## Reference Data Hook

The `useReferenceOptions` hook handles fetching options for select components:

```typescript
function useReferenceOptions(url: string, searchQuery: string = "") {
  const [options, setOptions] = useState<ReferenceOption[]>([]);
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  // Fetch data from API
  const { data, error: fetchError } = useSWR(
    searchQuery ? `${url}?search=${searchQuery}` : url,
    fetcher
  );
  
  // Process data into options format
  useEffect(() => {
    if (data?.items) {
      const formattedOptions = data.items.map(item => ({
        value: item._id,
        label: item.name || item.title || item.label,
      }));
      setOptions(formattedOptions);
      setIsLoading(false);
    }
    
    if (fetchError) {
      setError(fetchError);
      setIsLoading(false);
    }
  }, [data, fetchError]);
  
  return { options, error, isLoading };
}
```

[RULE] Use `useReferenceOptions` for all dropdown and multi-select inputs that fetch data.

</section>

<section id="data-server-actions">

## Server Actions

Server actions provide a way to perform server-side operations directly from client components:

```typescript
export async function createSchool(data: SchoolInput) {
  try {
    // Validate against schema
    const validated = SchoolInputZodSchema.parse(data);
    
    // Create in database
    const school = await SchoolModel.create(validated);
    
    // Return success response
    return { success: true, data: school };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return handleValidationError(error);
    }
    return handleServerError(error, "Failed to create school");
  }
}
```

[RULE] Always validate data with Zod schemas before database operations.

</section>

<section id="data-model-integration">

## MongoDB Model Integration

MongoDB models are defined using the Zod schemas:

```typescript
import { SchoolZodSchema } from "@/lib/zod-schema/core/school";
import mongoose from "mongoose";

const schemaFields = {
  schoolNumber: { type: String, required: true },
  district: { type: String, required: true },
  schoolName: { type: String, required: true },
  // Additional fields...
};

const SchoolSchema = new mongoose.Schema(schemaFields, { timestamps: true });

export const SchoolModel = mongoose.models.School || 
  mongoose.model("School", SchoolSchema);
```

[RULE] MongoDB models should reflect the structure defined in Zod schemas.

</section>

</doc>